// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: stripe.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AuthLoadBalancer_RegisterAuthServer_FullMethodName   = "/stripe.AuthLoadBalancer/RegisterAuthServer"
	AuthLoadBalancer_GetAuthServer_FullMethodName        = "/stripe.AuthLoadBalancer/GetAuthServer"
	AuthLoadBalancer_UpdateAuthServerLoad_FullMethodName = "/stripe.AuthLoadBalancer/UpdateAuthServerLoad"
)

// AuthLoadBalancerClient is the client API for AuthLoadBalancer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthLoadBalancerClient interface {
	RegisterAuthServer(ctx context.Context, in *ServerInfo, opts ...grpc.CallOption) (*Response, error)
	GetAuthServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerInfo, error)
	UpdateAuthServerLoad(ctx context.Context, in *AuthServerLoad, opts ...grpc.CallOption) (*Response, error)
}

type authLoadBalancerClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthLoadBalancerClient(cc grpc.ClientConnInterface) AuthLoadBalancerClient {
	return &authLoadBalancerClient{cc}
}

func (c *authLoadBalancerClient) RegisterAuthServer(ctx context.Context, in *ServerInfo, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AuthLoadBalancer_RegisterAuthServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authLoadBalancerClient) GetAuthServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerInfo)
	err := c.cc.Invoke(ctx, AuthLoadBalancer_GetAuthServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authLoadBalancerClient) UpdateAuthServerLoad(ctx context.Context, in *AuthServerLoad, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AuthLoadBalancer_UpdateAuthServerLoad_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthLoadBalancerServer is the server API for AuthLoadBalancer service.
// All implementations must embed UnimplementedAuthLoadBalancerServer
// for forward compatibility.
type AuthLoadBalancerServer interface {
	RegisterAuthServer(context.Context, *ServerInfo) (*Response, error)
	GetAuthServer(context.Context, *Empty) (*ServerInfo, error)
	UpdateAuthServerLoad(context.Context, *AuthServerLoad) (*Response, error)
	mustEmbedUnimplementedAuthLoadBalancerServer()
}

// UnimplementedAuthLoadBalancerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthLoadBalancerServer struct{}

func (UnimplementedAuthLoadBalancerServer) RegisterAuthServer(context.Context, *ServerInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterAuthServer not implemented")
}
func (UnimplementedAuthLoadBalancerServer) GetAuthServer(context.Context, *Empty) (*ServerInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthServer not implemented")
}
func (UnimplementedAuthLoadBalancerServer) UpdateAuthServerLoad(context.Context, *AuthServerLoad) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAuthServerLoad not implemented")
}
func (UnimplementedAuthLoadBalancerServer) mustEmbedUnimplementedAuthLoadBalancerServer() {}
func (UnimplementedAuthLoadBalancerServer) testEmbeddedByValue()                          {}

// UnsafeAuthLoadBalancerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthLoadBalancerServer will
// result in compilation errors.
type UnsafeAuthLoadBalancerServer interface {
	mustEmbedUnimplementedAuthLoadBalancerServer()
}

func RegisterAuthLoadBalancerServer(s grpc.ServiceRegistrar, srv AuthLoadBalancerServer) {
	// If the following call pancis, it indicates UnimplementedAuthLoadBalancerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthLoadBalancer_ServiceDesc, srv)
}

func _AuthLoadBalancer_RegisterAuthServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthLoadBalancerServer).RegisterAuthServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthLoadBalancer_RegisterAuthServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthLoadBalancerServer).RegisterAuthServer(ctx, req.(*ServerInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthLoadBalancer_GetAuthServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthLoadBalancerServer).GetAuthServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthLoadBalancer_GetAuthServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthLoadBalancerServer).GetAuthServer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthLoadBalancer_UpdateAuthServerLoad_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthServerLoad)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthLoadBalancerServer).UpdateAuthServerLoad(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthLoadBalancer_UpdateAuthServerLoad_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthLoadBalancerServer).UpdateAuthServerLoad(ctx, req.(*AuthServerLoad))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthLoadBalancer_ServiceDesc is the grpc.ServiceDesc for AuthLoadBalancer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthLoadBalancer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stripe.AuthLoadBalancer",
	HandlerType: (*AuthLoadBalancerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterAuthServer",
			Handler:    _AuthLoadBalancer_RegisterAuthServer_Handler,
		},
		{
			MethodName: "GetAuthServer",
			Handler:    _AuthLoadBalancer_GetAuthServer_Handler,
		},
		{
			MethodName: "UpdateAuthServerLoad",
			Handler:    _AuthLoadBalancer_UpdateAuthServerLoad_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stripe.proto",
}

const (
	BankLoadBalancer_GetAllBankServers_FullMethodName    = "/stripe.BankLoadBalancer/GetAllBankServers"
	BankLoadBalancer_RegisterBankServer_FullMethodName   = "/stripe.BankLoadBalancer/RegisterBankServer"
	BankLoadBalancer_GetBankServer_FullMethodName        = "/stripe.BankLoadBalancer/GetBankServer"
	BankLoadBalancer_UpdateBankServerLoad_FullMethodName = "/stripe.BankLoadBalancer/UpdateBankServerLoad"
)

// BankLoadBalancerClient is the client API for BankLoadBalancer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BankLoadBalancerClient interface {
	GetAllBankServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AllServersResponse, error)
	RegisterBankServer(ctx context.Context, in *ServerInfo, opts ...grpc.CallOption) (*Response, error)
	GetBankServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerInfo, error)
	UpdateBankServerLoad(ctx context.Context, in *BankServerLoad, opts ...grpc.CallOption) (*Response, error)
}

type bankLoadBalancerClient struct {
	cc grpc.ClientConnInterface
}

func NewBankLoadBalancerClient(cc grpc.ClientConnInterface) BankLoadBalancerClient {
	return &bankLoadBalancerClient{cc}
}

func (c *bankLoadBalancerClient) GetAllBankServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AllServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllServersResponse)
	err := c.cc.Invoke(ctx, BankLoadBalancer_GetAllBankServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankLoadBalancerClient) RegisterBankServer(ctx context.Context, in *ServerInfo, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, BankLoadBalancer_RegisterBankServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankLoadBalancerClient) GetBankServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerInfo)
	err := c.cc.Invoke(ctx, BankLoadBalancer_GetBankServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankLoadBalancerClient) UpdateBankServerLoad(ctx context.Context, in *BankServerLoad, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, BankLoadBalancer_UpdateBankServerLoad_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BankLoadBalancerServer is the server API for BankLoadBalancer service.
// All implementations must embed UnimplementedBankLoadBalancerServer
// for forward compatibility.
type BankLoadBalancerServer interface {
	GetAllBankServers(context.Context, *Empty) (*AllServersResponse, error)
	RegisterBankServer(context.Context, *ServerInfo) (*Response, error)
	GetBankServer(context.Context, *Empty) (*ServerInfo, error)
	UpdateBankServerLoad(context.Context, *BankServerLoad) (*Response, error)
	mustEmbedUnimplementedBankLoadBalancerServer()
}

// UnimplementedBankLoadBalancerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBankLoadBalancerServer struct{}

func (UnimplementedBankLoadBalancerServer) GetAllBankServers(context.Context, *Empty) (*AllServersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllBankServers not implemented")
}
func (UnimplementedBankLoadBalancerServer) RegisterBankServer(context.Context, *ServerInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterBankServer not implemented")
}
func (UnimplementedBankLoadBalancerServer) GetBankServer(context.Context, *Empty) (*ServerInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBankServer not implemented")
}
func (UnimplementedBankLoadBalancerServer) UpdateBankServerLoad(context.Context, *BankServerLoad) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBankServerLoad not implemented")
}
func (UnimplementedBankLoadBalancerServer) mustEmbedUnimplementedBankLoadBalancerServer() {}
func (UnimplementedBankLoadBalancerServer) testEmbeddedByValue()                          {}

// UnsafeBankLoadBalancerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BankLoadBalancerServer will
// result in compilation errors.
type UnsafeBankLoadBalancerServer interface {
	mustEmbedUnimplementedBankLoadBalancerServer()
}

func RegisterBankLoadBalancerServer(s grpc.ServiceRegistrar, srv BankLoadBalancerServer) {
	// If the following call pancis, it indicates UnimplementedBankLoadBalancerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BankLoadBalancer_ServiceDesc, srv)
}

func _BankLoadBalancer_GetAllBankServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankLoadBalancerServer).GetAllBankServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankLoadBalancer_GetAllBankServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankLoadBalancerServer).GetAllBankServers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankLoadBalancer_RegisterBankServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankLoadBalancerServer).RegisterBankServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankLoadBalancer_RegisterBankServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankLoadBalancerServer).RegisterBankServer(ctx, req.(*ServerInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankLoadBalancer_GetBankServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankLoadBalancerServer).GetBankServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankLoadBalancer_GetBankServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankLoadBalancerServer).GetBankServer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankLoadBalancer_UpdateBankServerLoad_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BankServerLoad)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankLoadBalancerServer).UpdateBankServerLoad(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankLoadBalancer_UpdateBankServerLoad_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankLoadBalancerServer).UpdateBankServerLoad(ctx, req.(*BankServerLoad))
	}
	return interceptor(ctx, in, info, handler)
}

// BankLoadBalancer_ServiceDesc is the grpc.ServiceDesc for BankLoadBalancer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BankLoadBalancer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stripe.BankLoadBalancer",
	HandlerType: (*BankLoadBalancerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllBankServers",
			Handler:    _BankLoadBalancer_GetAllBankServers_Handler,
		},
		{
			MethodName: "RegisterBankServer",
			Handler:    _BankLoadBalancer_RegisterBankServer_Handler,
		},
		{
			MethodName: "GetBankServer",
			Handler:    _BankLoadBalancer_GetBankServer_Handler,
		},
		{
			MethodName: "UpdateBankServerLoad",
			Handler:    _BankLoadBalancer_UpdateBankServerLoad_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stripe.proto",
}

const (
	Authentication_Register_FullMethodName = "/stripe.Authentication/Register"
	Authentication_Login_FullMethodName    = "/stripe.Authentication/Login"
)

// AuthenticationClient is the client API for Authentication service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthenticationClient interface {
	Register(ctx context.Context, in *ClientDetails, opts ...grpc.CallOption) (*Response, error)
	Login(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*AuthToken, error)
}

type authenticationClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthenticationClient(cc grpc.ClientConnInterface) AuthenticationClient {
	return &authenticationClient{cc}
}

func (c *authenticationClient) Register(ctx context.Context, in *ClientDetails, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Authentication_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationClient) Login(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*AuthToken, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthToken)
	err := c.cc.Invoke(ctx, Authentication_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthenticationServer is the server API for Authentication service.
// All implementations must embed UnimplementedAuthenticationServer
// for forward compatibility.
type AuthenticationServer interface {
	Register(context.Context, *ClientDetails) (*Response, error)
	Login(context.Context, *Credentials) (*AuthToken, error)
	mustEmbedUnimplementedAuthenticationServer()
}

// UnimplementedAuthenticationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthenticationServer struct{}

func (UnimplementedAuthenticationServer) Register(context.Context, *ClientDetails) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedAuthenticationServer) Login(context.Context, *Credentials) (*AuthToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthenticationServer) mustEmbedUnimplementedAuthenticationServer() {}
func (UnimplementedAuthenticationServer) testEmbeddedByValue()                        {}

// UnsafeAuthenticationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthenticationServer will
// result in compilation errors.
type UnsafeAuthenticationServer interface {
	mustEmbedUnimplementedAuthenticationServer()
}

func RegisterAuthenticationServer(s grpc.ServiceRegistrar, srv AuthenticationServer) {
	// If the following call pancis, it indicates UnimplementedAuthenticationServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Authentication_ServiceDesc, srv)
}

func _Authentication_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientDetails)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Authentication_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServer).Register(ctx, req.(*ClientDetails))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authentication_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Authentication_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServer).Login(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

// Authentication_ServiceDesc is the grpc.ServiceDesc for Authentication service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Authentication_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stripe.Authentication",
	HandlerType: (*AuthenticationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Authentication_Register_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Authentication_Login_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stripe.proto",
}

const (
	PaymentGateway_InitiateTransaction_FullMethodName   = "/stripe.PaymentGateway/InitiateTransaction"
	PaymentGateway_ConfirmTransaction_FullMethodName    = "/stripe.PaymentGateway/ConfirmTransaction"
	PaymentGateway_GetTransactionStatus_FullMethodName  = "/stripe.PaymentGateway/GetTransactionStatus"
	PaymentGateway_ProcessQueuedPayments_FullMethodName = "/stripe.PaymentGateway/ProcessQueuedPayments"
)

// PaymentGatewayClient is the client API for PaymentGateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentGatewayClient interface {
	InitiateTransaction(ctx context.Context, in *TransactionRequest, opts ...grpc.CallOption) (*TransactionResponse, error)
	ConfirmTransaction(ctx context.Context, in *TransactionConfirmation, opts ...grpc.CallOption) (*Response, error)
	GetTransactionStatus(ctx context.Context, in *TransactionID, opts ...grpc.CallOption) (*TransactionStatus, error)
	ProcessQueuedPayments(ctx context.Context, in *OfflineRequest, opts ...grpc.CallOption) (*Response, error)
}

type paymentGatewayClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentGatewayClient(cc grpc.ClientConnInterface) PaymentGatewayClient {
	return &paymentGatewayClient{cc}
}

func (c *paymentGatewayClient) InitiateTransaction(ctx context.Context, in *TransactionRequest, opts ...grpc.CallOption) (*TransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransactionResponse)
	err := c.cc.Invoke(ctx, PaymentGateway_InitiateTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentGatewayClient) ConfirmTransaction(ctx context.Context, in *TransactionConfirmation, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, PaymentGateway_ConfirmTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentGatewayClient) GetTransactionStatus(ctx context.Context, in *TransactionID, opts ...grpc.CallOption) (*TransactionStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransactionStatus)
	err := c.cc.Invoke(ctx, PaymentGateway_GetTransactionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentGatewayClient) ProcessQueuedPayments(ctx context.Context, in *OfflineRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, PaymentGateway_ProcessQueuedPayments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentGatewayServer is the server API for PaymentGateway service.
// All implementations must embed UnimplementedPaymentGatewayServer
// for forward compatibility.
type PaymentGatewayServer interface {
	InitiateTransaction(context.Context, *TransactionRequest) (*TransactionResponse, error)
	ConfirmTransaction(context.Context, *TransactionConfirmation) (*Response, error)
	GetTransactionStatus(context.Context, *TransactionID) (*TransactionStatus, error)
	ProcessQueuedPayments(context.Context, *OfflineRequest) (*Response, error)
	mustEmbedUnimplementedPaymentGatewayServer()
}

// UnimplementedPaymentGatewayServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPaymentGatewayServer struct{}

func (UnimplementedPaymentGatewayServer) InitiateTransaction(context.Context, *TransactionRequest) (*TransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateTransaction not implemented")
}
func (UnimplementedPaymentGatewayServer) ConfirmTransaction(context.Context, *TransactionConfirmation) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmTransaction not implemented")
}
func (UnimplementedPaymentGatewayServer) GetTransactionStatus(context.Context, *TransactionID) (*TransactionStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionStatus not implemented")
}
func (UnimplementedPaymentGatewayServer) ProcessQueuedPayments(context.Context, *OfflineRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessQueuedPayments not implemented")
}
func (UnimplementedPaymentGatewayServer) mustEmbedUnimplementedPaymentGatewayServer() {}
func (UnimplementedPaymentGatewayServer) testEmbeddedByValue()                        {}

// UnsafePaymentGatewayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentGatewayServer will
// result in compilation errors.
type UnsafePaymentGatewayServer interface {
	mustEmbedUnimplementedPaymentGatewayServer()
}

func RegisterPaymentGatewayServer(s grpc.ServiceRegistrar, srv PaymentGatewayServer) {
	// If the following call pancis, it indicates UnimplementedPaymentGatewayServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PaymentGateway_ServiceDesc, srv)
}

func _PaymentGateway_InitiateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentGatewayServer).InitiateTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentGateway_InitiateTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentGatewayServer).InitiateTransaction(ctx, req.(*TransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentGateway_ConfirmTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionConfirmation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentGatewayServer).ConfirmTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentGateway_ConfirmTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentGatewayServer).ConfirmTransaction(ctx, req.(*TransactionConfirmation))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentGateway_GetTransactionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentGatewayServer).GetTransactionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentGateway_GetTransactionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentGatewayServer).GetTransactionStatus(ctx, req.(*TransactionID))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentGateway_ProcessQueuedPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OfflineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentGatewayServer).ProcessQueuedPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentGateway_ProcessQueuedPayments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentGatewayServer).ProcessQueuedPayments(ctx, req.(*OfflineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentGateway_ServiceDesc is the grpc.ServiceDesc for PaymentGateway service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentGateway_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stripe.PaymentGateway",
	HandlerType: (*PaymentGatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitiateTransaction",
			Handler:    _PaymentGateway_InitiateTransaction_Handler,
		},
		{
			MethodName: "ConfirmTransaction",
			Handler:    _PaymentGateway_ConfirmTransaction_Handler,
		},
		{
			MethodName: "GetTransactionStatus",
			Handler:    _PaymentGateway_GetTransactionStatus_Handler,
		},
		{
			MethodName: "ProcessQueuedPayments",
			Handler:    _PaymentGateway_ProcessQueuedPayments_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stripe.proto",
}

const (
	BankServer_DeductMoney_FullMethodName      = "/stripe.BankServer/DeductMoney"
	BankServer_HasEnoughMoney_FullMethodName   = "/stripe.BankServer/HasEnoughMoney"
	BankServer_RegisterUser_FullMethodName     = "/stripe.BankServer/RegisterUser"
	BankServer_DepositMoney_FullMethodName     = "/stripe.BankServer/DepositMoney"
	BankServer_AbortTransaction_FullMethodName = "/stripe.BankServer/AbortTransaction"
)

// BankServerClient is the client API for BankServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BankServerClient interface {
	DeductMoney(ctx context.Context, in *DeductRequest, opts ...grpc.CallOption) (*DeductResponse, error)
	HasEnoughMoney(ctx context.Context, in *MoneyRequest, opts ...grpc.CallOption) (*MoneyResponse, error)
	RegisterUser(ctx context.Context, in *ClientDetails, opts ...grpc.CallOption) (*Response, error)
	DepositMoney(ctx context.Context, in *DepositRequest, opts ...grpc.CallOption) (*DepositResponse, error)
	AbortTransaction(ctx context.Context, in *TransactionID, opts ...grpc.CallOption) (*Response, error)
}

type bankServerClient struct {
	cc grpc.ClientConnInterface
}

func NewBankServerClient(cc grpc.ClientConnInterface) BankServerClient {
	return &bankServerClient{cc}
}

func (c *bankServerClient) DeductMoney(ctx context.Context, in *DeductRequest, opts ...grpc.CallOption) (*DeductResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeductResponse)
	err := c.cc.Invoke(ctx, BankServer_DeductMoney_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankServerClient) HasEnoughMoney(ctx context.Context, in *MoneyRequest, opts ...grpc.CallOption) (*MoneyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MoneyResponse)
	err := c.cc.Invoke(ctx, BankServer_HasEnoughMoney_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankServerClient) RegisterUser(ctx context.Context, in *ClientDetails, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, BankServer_RegisterUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankServerClient) DepositMoney(ctx context.Context, in *DepositRequest, opts ...grpc.CallOption) (*DepositResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DepositResponse)
	err := c.cc.Invoke(ctx, BankServer_DepositMoney_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankServerClient) AbortTransaction(ctx context.Context, in *TransactionID, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, BankServer_AbortTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BankServerServer is the server API for BankServer service.
// All implementations must embed UnimplementedBankServerServer
// for forward compatibility.
type BankServerServer interface {
	DeductMoney(context.Context, *DeductRequest) (*DeductResponse, error)
	HasEnoughMoney(context.Context, *MoneyRequest) (*MoneyResponse, error)
	RegisterUser(context.Context, *ClientDetails) (*Response, error)
	DepositMoney(context.Context, *DepositRequest) (*DepositResponse, error)
	AbortTransaction(context.Context, *TransactionID) (*Response, error)
	mustEmbedUnimplementedBankServerServer()
}

// UnimplementedBankServerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBankServerServer struct{}

func (UnimplementedBankServerServer) DeductMoney(context.Context, *DeductRequest) (*DeductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeductMoney not implemented")
}
func (UnimplementedBankServerServer) HasEnoughMoney(context.Context, *MoneyRequest) (*MoneyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasEnoughMoney not implemented")
}
func (UnimplementedBankServerServer) RegisterUser(context.Context, *ClientDetails) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterUser not implemented")
}
func (UnimplementedBankServerServer) DepositMoney(context.Context, *DepositRequest) (*DepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositMoney not implemented")
}
func (UnimplementedBankServerServer) AbortTransaction(context.Context, *TransactionID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortTransaction not implemented")
}
func (UnimplementedBankServerServer) mustEmbedUnimplementedBankServerServer() {}
func (UnimplementedBankServerServer) testEmbeddedByValue()                    {}

// UnsafeBankServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BankServerServer will
// result in compilation errors.
type UnsafeBankServerServer interface {
	mustEmbedUnimplementedBankServerServer()
}

func RegisterBankServerServer(s grpc.ServiceRegistrar, srv BankServerServer) {
	// If the following call pancis, it indicates UnimplementedBankServerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BankServer_ServiceDesc, srv)
}

func _BankServer_DeductMoney_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankServerServer).DeductMoney(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankServer_DeductMoney_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankServerServer).DeductMoney(ctx, req.(*DeductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankServer_HasEnoughMoney_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoneyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankServerServer).HasEnoughMoney(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankServer_HasEnoughMoney_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankServerServer).HasEnoughMoney(ctx, req.(*MoneyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankServer_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientDetails)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankServerServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankServer_RegisterUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankServerServer).RegisterUser(ctx, req.(*ClientDetails))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankServer_DepositMoney_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankServerServer).DepositMoney(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankServer_DepositMoney_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankServerServer).DepositMoney(ctx, req.(*DepositRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankServer_AbortTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankServerServer).AbortTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankServer_AbortTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankServerServer).AbortTransaction(ctx, req.(*TransactionID))
	}
	return interceptor(ctx, in, info, handler)
}

// BankServer_ServiceDesc is the grpc.ServiceDesc for BankServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BankServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stripe.BankServer",
	HandlerType: (*BankServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeductMoney",
			Handler:    _BankServer_DeductMoney_Handler,
		},
		{
			MethodName: "HasEnoughMoney",
			Handler:    _BankServer_HasEnoughMoney_Handler,
		},
		{
			MethodName: "RegisterUser",
			Handler:    _BankServer_RegisterUser_Handler,
		},
		{
			MethodName: "DepositMoney",
			Handler:    _BankServer_DepositMoney_Handler,
		},
		{
			MethodName: "AbortTransaction",
			Handler:    _BankServer_AbortTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stripe.proto",
}

const (
	TwoPhaseCommit_ReadyToCommitTransaction_FullMethodName = "/stripe.TwoPhaseCommit/ReadyToCommitTransaction"
	TwoPhaseCommit_CommitTransaction_FullMethodName        = "/stripe.TwoPhaseCommit/CommitTransaction"
	TwoPhaseCommit_AbortTransaction_FullMethodName         = "/stripe.TwoPhaseCommit/AbortTransaction"
)

// TwoPhaseCommitClient is the client API for TwoPhaseCommit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TwoPhaseCommitClient interface {
	ReadyToCommitTransaction(ctx context.Context, in *TransactionDetails, opts ...grpc.CallOption) (*Vote, error)
	CommitTransaction(ctx context.Context, in *TransactionDetails, opts ...grpc.CallOption) (*Response, error)
	AbortTransaction(ctx context.Context, in *TransactionID, opts ...grpc.CallOption) (*Response, error)
}

type twoPhaseCommitClient struct {
	cc grpc.ClientConnInterface
}

func NewTwoPhaseCommitClient(cc grpc.ClientConnInterface) TwoPhaseCommitClient {
	return &twoPhaseCommitClient{cc}
}

func (c *twoPhaseCommitClient) ReadyToCommitTransaction(ctx context.Context, in *TransactionDetails, opts ...grpc.CallOption) (*Vote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Vote)
	err := c.cc.Invoke(ctx, TwoPhaseCommit_ReadyToCommitTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitClient) CommitTransaction(ctx context.Context, in *TransactionDetails, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TwoPhaseCommit_CommitTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitClient) AbortTransaction(ctx context.Context, in *TransactionID, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TwoPhaseCommit_AbortTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TwoPhaseCommitServer is the server API for TwoPhaseCommit service.
// All implementations must embed UnimplementedTwoPhaseCommitServer
// for forward compatibility.
type TwoPhaseCommitServer interface {
	ReadyToCommitTransaction(context.Context, *TransactionDetails) (*Vote, error)
	CommitTransaction(context.Context, *TransactionDetails) (*Response, error)
	AbortTransaction(context.Context, *TransactionID) (*Response, error)
	mustEmbedUnimplementedTwoPhaseCommitServer()
}

// UnimplementedTwoPhaseCommitServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTwoPhaseCommitServer struct{}

func (UnimplementedTwoPhaseCommitServer) ReadyToCommitTransaction(context.Context, *TransactionDetails) (*Vote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadyToCommitTransaction not implemented")
}
func (UnimplementedTwoPhaseCommitServer) CommitTransaction(context.Context, *TransactionDetails) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitTransaction not implemented")
}
func (UnimplementedTwoPhaseCommitServer) AbortTransaction(context.Context, *TransactionID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortTransaction not implemented")
}
func (UnimplementedTwoPhaseCommitServer) mustEmbedUnimplementedTwoPhaseCommitServer() {}
func (UnimplementedTwoPhaseCommitServer) testEmbeddedByValue()                        {}

// UnsafeTwoPhaseCommitServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TwoPhaseCommitServer will
// result in compilation errors.
type UnsafeTwoPhaseCommitServer interface {
	mustEmbedUnimplementedTwoPhaseCommitServer()
}

func RegisterTwoPhaseCommitServer(s grpc.ServiceRegistrar, srv TwoPhaseCommitServer) {
	// If the following call pancis, it indicates UnimplementedTwoPhaseCommitServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TwoPhaseCommit_ServiceDesc, srv)
}

func _TwoPhaseCommit_ReadyToCommitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionDetails)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitServer).ReadyToCommitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommit_ReadyToCommitTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitServer).ReadyToCommitTransaction(ctx, req.(*TransactionDetails))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommit_CommitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionDetails)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitServer).CommitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommit_CommitTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitServer).CommitTransaction(ctx, req.(*TransactionDetails))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommit_AbortTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitServer).AbortTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommit_AbortTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitServer).AbortTransaction(ctx, req.(*TransactionID))
	}
	return interceptor(ctx, in, info, handler)
}

// TwoPhaseCommit_ServiceDesc is the grpc.ServiceDesc for TwoPhaseCommit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TwoPhaseCommit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stripe.TwoPhaseCommit",
	HandlerType: (*TwoPhaseCommitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadyToCommitTransaction",
			Handler:    _TwoPhaseCommit_ReadyToCommitTransaction_Handler,
		},
		{
			MethodName: "CommitTransaction",
			Handler:    _TwoPhaseCommit_CommitTransaction_Handler,
		},
		{
			MethodName: "AbortTransaction",
			Handler:    _TwoPhaseCommit_AbortTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stripe.proto",
}

const (
	LoggingService_LogTransaction_FullMethodName = "/stripe.LoggingService/LogTransaction"
)

// LoggingServiceClient is the client API for LoggingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoggingServiceClient interface {
	LogTransaction(ctx context.Context, in *LogEntry, opts ...grpc.CallOption) (*Response, error)
}

type loggingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoggingServiceClient(cc grpc.ClientConnInterface) LoggingServiceClient {
	return &loggingServiceClient{cc}
}

func (c *loggingServiceClient) LogTransaction(ctx context.Context, in *LogEntry, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, LoggingService_LogTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoggingServiceServer is the server API for LoggingService service.
// All implementations must embed UnimplementedLoggingServiceServer
// for forward compatibility.
type LoggingServiceServer interface {
	LogTransaction(context.Context, *LogEntry) (*Response, error)
	mustEmbedUnimplementedLoggingServiceServer()
}

// UnimplementedLoggingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLoggingServiceServer struct{}

func (UnimplementedLoggingServiceServer) LogTransaction(context.Context, *LogEntry) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogTransaction not implemented")
}
func (UnimplementedLoggingServiceServer) mustEmbedUnimplementedLoggingServiceServer() {}
func (UnimplementedLoggingServiceServer) testEmbeddedByValue()                        {}

// UnsafeLoggingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoggingServiceServer will
// result in compilation errors.
type UnsafeLoggingServiceServer interface {
	mustEmbedUnimplementedLoggingServiceServer()
}

func RegisterLoggingServiceServer(s grpc.ServiceRegistrar, srv LoggingServiceServer) {
	// If the following call pancis, it indicates UnimplementedLoggingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LoggingService_ServiceDesc, srv)
}

func _LoggingService_LogTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggingServiceServer).LogTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoggingService_LogTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggingServiceServer).LogTransaction(ctx, req.(*LogEntry))
	}
	return interceptor(ctx, in, info, handler)
}

// LoggingService_ServiceDesc is the grpc.ServiceDesc for LoggingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoggingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stripe.LoggingService",
	HandlerType: (*LoggingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LogTransaction",
			Handler:    _LoggingService_LogTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stripe.proto",
}

const (
	OfflineQueueService_ProcessQueuedPayments_FullMethodName = "/stripe.OfflineQueueService/ProcessQueuedPayments"
)

// OfflineQueueServiceClient is the client API for OfflineQueueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OfflineQueueServiceClient interface {
	ProcessQueuedPayments(ctx context.Context, in *OfflineRequest, opts ...grpc.CallOption) (*Response, error)
}

type offlineQueueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOfflineQueueServiceClient(cc grpc.ClientConnInterface) OfflineQueueServiceClient {
	return &offlineQueueServiceClient{cc}
}

func (c *offlineQueueServiceClient) ProcessQueuedPayments(ctx context.Context, in *OfflineRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, OfflineQueueService_ProcessQueuedPayments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OfflineQueueServiceServer is the server API for OfflineQueueService service.
// All implementations must embed UnimplementedOfflineQueueServiceServer
// for forward compatibility.
type OfflineQueueServiceServer interface {
	ProcessQueuedPayments(context.Context, *OfflineRequest) (*Response, error)
	mustEmbedUnimplementedOfflineQueueServiceServer()
}

// UnimplementedOfflineQueueServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOfflineQueueServiceServer struct{}

func (UnimplementedOfflineQueueServiceServer) ProcessQueuedPayments(context.Context, *OfflineRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessQueuedPayments not implemented")
}
func (UnimplementedOfflineQueueServiceServer) mustEmbedUnimplementedOfflineQueueServiceServer() {}
func (UnimplementedOfflineQueueServiceServer) testEmbeddedByValue()                             {}

// UnsafeOfflineQueueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OfflineQueueServiceServer will
// result in compilation errors.
type UnsafeOfflineQueueServiceServer interface {
	mustEmbedUnimplementedOfflineQueueServiceServer()
}

func RegisterOfflineQueueServiceServer(s grpc.ServiceRegistrar, srv OfflineQueueServiceServer) {
	// If the following call pancis, it indicates UnimplementedOfflineQueueServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OfflineQueueService_ServiceDesc, srv)
}

func _OfflineQueueService_ProcessQueuedPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OfflineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OfflineQueueServiceServer).ProcessQueuedPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OfflineQueueService_ProcessQueuedPayments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OfflineQueueServiceServer).ProcessQueuedPayments(ctx, req.(*OfflineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OfflineQueueService_ServiceDesc is the grpc.ServiceDesc for OfflineQueueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OfflineQueueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stripe.OfflineQueueService",
	HandlerType: (*OfflineQueueServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProcessQueuedPayments",
			Handler:    _OfflineQueueService_ProcessQueuedPayments_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stripe.proto",
}
